Amennyiben a Linux-on egy Windows 2008 R2 szerinti Active Directory-s körülmény áll rendelkezésre, amit a samba, vagyis az eredendõen filemegosztásra szolgáló szerverfunkció révén hozhatunk létre, az Active Directory-s központi adminisztrációval a samba-tool parancs révén tud összeköttetésbe kerülni.

Mire használtuk fel tényleges a samba-tool-t?

Ezzel alakítottuk ki végülis Linux-ban az Active Directory tarományt.

samba-tool domain provision elidított egy folyamatot, ami rákerdezett legelõször a domain controller mivoltára a szervernek, a tartománynévre, a NETBIOS tartománynévre, az Active Directory névfeloldási hátterére, DNS forwarder-re és végül a tartományi administrator jelszavára.


samba-tool domain level show -> ez mondta meg, hogy Windows 2008 R2 szerinti tartományi környezettel van dolgunk

(samba-tool user create nyilvánvalóan alkalmas arra, hogy a Windows Server PowerShell-jében alkalmazott New-ADUser cmdlet-jével megegyezõen tudjunk felhasználókat létrehozni)


Amennyiben a Linux gép Active Directory tartomány PDC-je lehetséges egy közönséges asztali Windows operációs rendszerû, tartomány felhasználói számítógéprõl/munkaállomásról/workstation-rõl a Microsoft RSAT programcsomagja révén is tartománnyal összefüggõ konfigurálásokat végezni.
Remote Server Administration Tool, ami lényegében mindenféle Windows-os szerverszerepkör konfiguráció MMC programját tartalmazva lehetõvé teszi, hogy ne a szerverrõl, hanem egy közönséges számítógéprõl végezhessük a szerver(ei)ünk beállításait.


Ha a Linux esetén telepítésre került a VirtualBox integrációs szolgáltaásai nevezetû programcsomag, használhatjuk a Megosztott mappa nyújtotta lehetõséget:

mount -t vboxsf Documents /mnt paranccsal, ha a gazdagép Dokumentumok könyvtárát, mint megosztott mappát meghatároztuk a virtuális gép Eszközök/Megosztott mappák funkciójában csatolhatjuk a mûködõ Linux rendszerünk merevlemezén található mnt könyvtárba, hogy természetesen azon keszetül férhessünk hozzá és így közvetlen adatcsere-bere valósulhasson meg a virtuális és gazda gépek között.

(csekkolás. cd /mnt majd ls -al)

Pelda1.sh néven hozzunk létre a Windows-ban (ami össze van kapcsolva a Linux-szal) egy egyszerû szöveges file-t.

(ahhoz, hogy Linux/UNIX rendszerben egy közönséges szöveges állomány futtatható legyen a chmod +x <filenév> parancsot kell használni. Ennek következtében a file-ra vonatkozó jogosultságok között tulajdonos, csoport és mindenki más vonatkozásában megjelenik az x <=> eXecute/végrehajtható jogra történõ utalás)

A futtatás kipróbálása: ./Pelda1.sh vagy mc-ben egyszerûen egy Enter ütés a file kiválasztása után

(Windows esetén az alapértelmezett kódolás jellemzõen Windows-1250 vagy a kb azzal egyenértékû: ISO-8859-2 latin 2-es kódolás, míg a Linux esetén az UTF-8 érvényesül)

Míg a PowerShell-ben a változókat mindig dollárjellel kezdve kell szerepeltetni, a Linux/UNIX shell-script-ekben csak akkor, amikor az értékükhöz, vagyis a változó neve által meghatározott memóriaterület tartalmához kívánunk hozzáférni

(a Linux-ban a man echo paranccsal tájékozódhatunk arról, hogy ez pl. miként használható)

Ha Active Directory-s mûködés van egy Linux/Unix rendszerben, akkor fontos hangsúlyoznom, hogy vannak tartományi felhasználók és vannak alaprendszerhez kapcsolódó felhasználók is (szükségképpen ezek akár teljesen különbözõk is lehetnek)

cat /etc/passwd (ebben látszanak az alaprendszer felhasználóival kapcsolatos nyilvános adatok)

A Linux rendszerhez közvetlenül tartozó felhasználókat az adduser valamint a useradd parancsokkal hozhatjuk létre

(az adduser lényegében egy perl-script állomány, tehát a shell-script-ekhez hasonló egyszerû szöveges file-ként lesz a rendszerünkben megtalálható /which adduser/)

adduser user2 (látható, hogy eléggé interaktív, minek következtében ha shell script-ben használnánk továbbítani kellene a most billentyûzeten keresztül beírt tartalmakat, useradd nem interaktív, így könnyebben lesz script-ekben is alkalmazható)

passwd user2 paranccsal lesz lehetõség az adott felhasználó jelszavát módosítani, amennyi root-ként vagyunk bejelentkezve (nem root, tehát nem superuser csak a saját jelszavát módosíthatja)

^M a Windows-ban, amikor leütjük az Enter-t, akkor egy ASCII 13 (CR=kocsi-vissza) és egy ASCII 10 (LF=soremelés) karakter kerül az adott pozícióba, így ha egy ilyen file-t használunk a Linux-ban a ^M, ami a CR-nek megfelelõ szimbólum, gondot okozhat. Linux-ban az Enter leütésekor csak egy LF kerül az adott pozícióba, míg a MacOSX-ben pedig csak egy CR, így ezeket például a Windows notepad programja lehetséges, hogy nem fogja tudni jól értelmezni és ezért összefolyik a szöveg, nem tagolódik megfelelõen sorokra

JAVÍTÁS: el kellett tüntetni a ^M-eket és az echo -e "$jalszo\n$jelszo\n"|passwd user2 módon kellett a parancsot kiadni, tehát az echo által kiírandókat idézõjelek közé kellett tenni.

Mivel a PowerShell-ben az igen változatos felhasználók kialakítása végett csináltunk egy alap.txt állományt, amiben bizonyos sorokban vezeték- és utónevek pontosvesszõvel elválasztva szerepeltek, majd egy idõ múlva már csak utónevek, természetesen úgy, hogy azok elõtt szintén szerepelt egy pontosvesszõ.

Készítsünk olyan shell-script-et, ami képes egy ilyen file-t létrehozni úgy, hogy annak tartalmát mûködése közben kell begépelni. A program kérje be tehát a vezeték- és utónevet, amelyek esetén bármelyik megadása elhagyható, amennyiben egyiket sem adjuk meg, akkor viszont szeretnénk, ha befejezõdne ez az ismétlõdõ folyamat (CIKLUS)

A Linux shell script-ben a -eq, -ne, -lt, -le, -gt, -ge relációs megfogalmazások csak számadatok esetén használhatók.
Szöveg esetén az egyenlõség, ahogy az if példában volt látható egy szimpla egyenlõségjellel használandó (nem úgy, mint Python-ban, ahol == jelet kell használni.
Mind a ciklus, mind az elágazás feltételénél szerepel a szögletes zárójelezés, ami a shell script-ekben jellemzõen igaz, hamis eredményt szolgáltató másfajta vizsgálatok végrehajtásakor is használható
Az if esetén "$vnev" = "" megfogalmazással kívántuk megállapítani, hogy a vnev változónak nincs értéke


Az alapadatok.txt felhasználásával képesek lehetünk valódi Vezeték- és Utónevek alapján véletlenszerû személyeket meghatározni (nagybetûvel kezdõdnek, ékezetes betûket tartalmaznak)

Ékezetlenítés, kisbetûssé alakítás:

nev="Bálint Dezsõ";echo ${nev,,} kisbetûssé alakult
nev="Bálint Dezsõ";echo ${nev^^} nagybetûssé alakult
nev="Bálint Dezsõ";echo "$nev"|tr '[:upper:]' '[:lower:]' kisbetûssé alakult

echo "Árvíztûrõtükörfúrógép"|awk '{print tolower($0)}'
echo "Árvíztûrõtükörfúrógép"|awk '{print toupper($0)}'
A fenti parancsok kisbetûssé és nagybetûssé alakítást csak a standard ASCII 7 bit-es, tehát a latin vagy angol ABC betûire teszik alkalmazhatóvá


echo "Árvíztûrõtükörfúrógép"|iconv -f UTF-8 -t ASCII//TRANSLIT

hatására: A'rvi'ztu"ro"tu:ko:rfu'ro'ge'p (repülõ éekezetekkel oldja meg az ékezetes betûk eltüntetését, ez azonban a felhasználói nevek esetén igényelt megoldáshoz nem jó, mert ',",: mint különleges karakterek a felhasználók azonosítóiban nem használhatók
(miért nem lehet akármilyen azonosítóban kettõspont a Windows OS-ekben? azért mert pl. c: jelölésnél egy lemezegységre utaló hivatkozásban szerepelhet)


Az apt install unaccent segíségével telepíthetjük fel az alaptelepítésben nem szereplõ másik ékezetlenítõt

echo "Árvíztûrõtükörfúrógép"|unaccent utf-8

