mount -t vboxsf Documents /mnt

A shell script-ek tömbjei:

tomb=(elem1 eleme2 elem3) módon lesz taxative meghatározható (felsoroltuk az elemeket)
tomb=() üres tömböt vettük figyelembe

(Amint látható érvényesül a shell script változók értékadásánál tapasztalható jelenség, vagyis, hogy ekkor nem kell dollárjel)

echo $tomb

Itt már a változó tarlmára vagyunk kíváncsiak tehát kell a $. Ekkor azonban nem a tömb valamennyi elemét, hanem csak az elsõt láthatjuk viszont. Ha egy meghatározott indexû elemre vagyunk kíváncsiak, akkor ${tomb[3]} módon kell hivatkozni, ebben a konkrét esetben, mivel a tömb elemeit, mint a Python-ban is 0-tól sorszámozzuk, lényegében a 4. elemet fogjuk tudni megjeleníteni.


${tomb[@]} illetve az ezzel egyenértékû ${tomb[*]}
(Ilyenkor szóközökkel tagolva teszi láthatóvá a tömb valamennyi elemét)

${#tomb} megmutatja az elemek darabszámát
${!tomb[@]} pedig láthatóvá teszi az elemek 0-tól kezdõdõ, természetesen a darbaszámuk-1-ig terjedõ lehetséges index értékeit

 ${#tomb[0]} ezzel lényegében a 0. indexû, tehát a tömb elsõ elemének hosszát leszünk képesek megállapíani
 
 Saját tömb létrehozása kapcsán használható a seq 1 5 parancs, amely 1-tõl 5-ig felsorolja a számokat, de így biztosíthatja azok alapján pl. a tömb elemek darabszámának meghatározását.
 
(Lottószám kellene pont 5 darab, amit ennek segítségével állíthatnánk elõ.
$RANDOM elõállít 2 byte-os véletlen pozitív egészeket (0-32767)
Hogy lottószám legyen (1-90)
echo $(($RANDOM%90+1)) ezzel a maradékos osztáson alapuló számítás eredményét, mint egy változót fog megjeleníteni az echo

ha van egy lottoszamok=() üres tömbünk, akkor ahhoz

lottoszamok+=($(($RANDOM%90+1))) adhatunk hozzá valóságos lottószámokat, amiket azután:

echo ${lottoszamok[@]} paranccsal egymástó szóközzel szeparálva tehetünk láthatóvá


/dev/random illetve /dev/urandom olyan speciális eszközöket jelölnek, amelyek lényegében egy véletlenszerû adatfolyamnak bytesorozatnak tekinthetõk.

(/dev/sr0 pl. a CD/DVD eszközt reprezentálta

mount /dev/sr0 /media/cdrom0 vagyis a CD/DVD lemezegységet reprezentáló eszközzel tudtuk a rendszerünkhöz csatolni pl. az integrációs szolgáltatások telepítõ lemezét, hogy a VBoxGuestAdditions a Linux-ra telepíthetõ legyen

/dev/sda magát a merevlemezt jelölõ eszköz: s - sata/scsi, a - az elsõ ilyen lemez, mert b - a második, c - a harmadik stb.
/dev/sda1 pedig az adott merevlemez 1 partícióját jelöli)


pl. 
od -A n -N 1 -t d < /dev/urandom
(man od)

esetén az urandom eszköz által szolgáltatott végeláthatatlan adatfolyamból számrendszere nem vonatkozóan: -A n, egy byte-ot: -N 1, mint decimális értéket: -t d veszünk figyelembe. Tehát az od parancs az input átirányítás (<) révén jut az adatfolyamhoz, hogy paraméterezése szerint értelmezhesse azt

echo $(($(od -A n -N 2 -i /dev/random)%5))

man shuf egy másik parancs, amit egy sorokat megjelenítõ paranccsal összekombinálva használhatunk arra, hogy a megjelenõ sorok közül egy legyen véletlenszerûen kiválasztva

shuf -i 1-10 -n 1
pl. lottószámok shuf -i 1-90 -n 5

Próbáljuk meg elkészíteni azt a programot, amely elsõként felépíti a vnevek és unevek kezdetben üres tömböket, hogy azokban az alapadatok.txt korábban tárolt file megfelelõ értékei legyenek megtalálhatók és így lehetõség nyílik egy véletlen vezeték- és utónév kiválasztásával meghatározni egy konkrét személy nevét.

touch Pelda5.sh
chmod +x Pelda5.sh
Ilyen elõkészületek után a mc-edit-tel (A Midnight Commander editora) tudjuk szerkeszteni

#!/bin/bash
vnevek=()
unevek=()
db=1
while read sor
do
    if [ $db -gt 1 ]
    then
	vnev=`echo $sor|awk -F";" '{print $1}'`
	unev=`echo $sor|awk -F";" '{print $2}'`
	if [ "$vnev" != "" ]
	then
	    vnevek+=($vnev)
	fi
	if [ "$unev" != "" ]
	then
	    unevek+=($unev)
	fi
    fi
    db=`expr $db + 1`
done<alapadatok.txt
echo "Vezetéknevek száma: ${#vnevek[@]} ${vnevek[*]}"
echo "Utónevek száma: ${#unevek[@]} ${unevek[*]}"
vnev=`for s in $vnevek;do echo $s;done|shuf -n 1`
unev=`for s in $unevek;do echo $s;done|shuf -n 1`
echo "$vnev $unev"
